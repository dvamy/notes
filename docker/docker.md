# docker是一个快速交付、运行应用的技术


## docker解决依赖兼容问题

```
1. 将应用的libs（函数库）、deps（依赖）、配置与应用一起打包，形成可移植现象。

2. 将每个应用放到一个隔离容器中去运行，避免相互干扰，使用沙箱机制，相互隔离。
```

ubuntu和centos都是基于linux内核，只是系统应用不同，提供的函数库有差异。

## docker如何解决不同系统环境的问题

```
1. docker将用户程序与所需要调用的系统函数库一起打包。
2. docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的linux来运行。
//docker镜像中包含完整的与性能环境，包括系统函数库，可以认为docker打包好的程序包可以运行在任何一个linux内核的操作系统中。
```
启动和移除都可以通过一行命令完成，方便快捷。


# docker与虚拟机

```
1.虚拟机是在操作系统中模拟硬件设备，然后运行另一个操作系统.
2.docker不需要模拟出整个操作系统，只需要模拟出一个小规模的环境。
```
### 性能区别

```
1. docker是一个系统进程，虚拟机是在操作系统中的操作系统；
2.  docker体积小、启动速度快，性能好，接近原生，磁盘占用一般为MB，启动也是秒级；
3  虚拟机体积小，启动速度快、性能好，虚拟机体积大速度慢，性能一般；
1.  虚拟机性能较差，磁盘占用一般为分钟级，相当于把操作系统重启。
```

# 镜像和容器

### 镜像
```
docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。
//本质上，docker镜像是一个linux的文件系统，包含可以运行在Linux内核的程序及相应的数据。
```
#### 镜像特征
```
1. 分层：一个镜像可以由多个中间层组成，多个镜像可以共享同一中间层；镜像和中间层是多对多的关系。
2. 只读：镜像在构建完成后不可修改。
```

### 容器
```
镜像中的应用程序运行后形成的进程就是容器。docker会给容器做隔离，对外不可见。
```
### 镜像和容器的关系
```
容器是通过镜像来创建的，所以必须现有镜像才能创建容器。生成的容器是一个独立于宿主机的隔离进程，并且有属于容器自己的网络和命名空间。镜像构建完成后不可修改，容器是可以动态改变的。
```

# Docker和DockerHub
```
DockerHub是一个Docker镜像托管平台，统称为Docker Registry。
```

# Docker架构
```
Docker是一个CS架构的程序，由服务端和客户端组成。
服务端（Server）：Docker守护进程，负责处理Docker指令，管理镜像、容器等。
客户管（Client）：通过命令或RestAPI向Docker服务端发送指令，可以在本地或远程向服务端发送指令。
```
### 构建镜像
1. 在本地通过命令形式:
   
Client上通过 **docker build** 命令构建一个镜像，这个命令到达DockerServer之后，被 **docker daemon  守护进程** 接收和处理，利用提供的数据，构建一个镜像。

2. 从Registry拉去镜像：
Client上通过 **docker pull** 命令，DockerServer的守护进程会去从Registry中拉去指定的镜像

### 运行镜像创建容器
Clinet上通过 **docker run** 告诉Server要创建进程。








